---
title: Rate Limits
description: Understanding rate limits and optimization strategies
---

# Rate Limits

The Norai API implements rate limiting to ensure fair usage and maintain service quality for all users. Understanding these limits will help you build robust integrations.

## Rate Limit Tiers

Rate limits vary by account tier:

### Free Tier
- **Events API**: 100 events/minute
- **Recommendations API**: 10 requests/minute
- **Other endpoints**: 100 requests/minute
- **Daily limit**: 10,000 events/day

### Professional Tier
- **Events API**: 1,000 events/minute
- **Recommendations API**: 100 requests/minute
- **Other endpoints**: 500 requests/minute
- **Daily limit**: 1,000,000 events/day

### Enterprise Tier
- **Events API**: 10,000 events/minute
- **Recommendations API**: 1,000 requests/minute
- **Other endpoints**: 2,000 requests/minute
- **Daily limit**: Unlimited

## Rate Limit Headers

All API responses include headers that indicate your current rate limit status:

```
X-RateLimit-Limit: 100
X-RateLimit-Remaining: 95
X-RateLimit-Reset: 1701604800
```

- `X-RateLimit-Limit`: Maximum requests allowed in the current window
- `X-RateLimit-Remaining`: Number of requests remaining
- `X-RateLimit-Reset`: Unix timestamp when the rate limit resets

## Handling Rate Limits

### Check Headers

Always check rate limit headers before making requests:

```javascript
const response = await fetch('https://api.norai.com/ml/generate-recommendations', {
  method: 'POST',
  headers: {
    'Authorization': `Bearer ${API_KEY}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify(requestData)
});

const remaining = response.headers.get('X-RateLimit-Remaining');
const reset = response.headers.get('X-RateLimit-Reset');

console.log(`Requests remaining: ${remaining}`);
console.log(`Resets at: ${new Date(reset * 1000)}`);
```

### 429 Response

When you exceed the rate limit, you'll receive a 429 status code:

```json
{
  "success": false,
  "error": {
    "code": "rate_limit_exceeded",
    "message": "Rate limit exceeded. Try again in 60 seconds",
    "details": {
      "retry_after": 60,
      "limit": 100,
      "window": "1m"
    }
  }
}
```

### Retry with Exponential Backoff

Implement exponential backoff when you hit rate limits:

```javascript
async function fetchWithBackoff(url, options, maxRetries = 3) {
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    const response = await fetch(url, options);
    
    if (response.status === 429) {
      const retryAfter = response.headers.get('Retry-After') || Math.pow(2, attempt);
      console.log(`Rate limited. Retrying after ${retryAfter}s`);
      await new Promise(resolve => setTimeout(resolve, retryAfter * 1000));
      continue;
    }
    
    return response;
  }
  throw new Error('Max retries exceeded');
}
```

## Optimization Strategies

### 1. Batch Requests

Use batch endpoints to reduce the number of API calls:

```javascript
// Instead of multiple single event requests
for (const event of events) {
  await trackEvent(event);  // Multiple API calls
}

// Use batch endpoint
await trackEvents({
  project_id: 'proj_abc123',
  events: events  // Single API call
});
```

### 2. Cache Recommendations

Cache recommendations to reduce API calls:

```javascript
const cache = new Map();
const CACHE_TTL = 5 * 60 * 1000; // 5 minutes

async function getCachedRecommendations(userId) {
  const cacheKey = `recs_${userId}`;
  const cached = cache.get(cacheKey);
  
  if (cached && Date.now() - cached.timestamp < CACHE_TTL) {
    return cached.data;
  }
  
  const recommendations = await fetchRecommendations(userId);
  cache.set(cacheKey, {
    data: recommendations,
    timestamp: Date.now()
  });
  
  return recommendations;
}
```

### 3. Use Webhooks

For batch operations, use webhooks instead of polling:

```javascript
// Instead of polling for job status
async function pollJobStatus(jobId) {
  while (true) {
    const status = await getJobStatus(jobId);  // Multiple API calls
    if (status.completed) return status;
    await new Promise(resolve => setTimeout(resolve, 5000));
  }
}

// Set up a webhook to receive completion notifications
await createSegmentJob({
  project_id: 'proj_abc123',
  webhook_url: 'https://yourapp.com/webhooks/segments'  // No polling needed
});
```

### 4. Optimize Event Tracking

Send events in batches and use client-side queuing:

```javascript
class EventQueue {
  constructor() {
    this.queue = [];
    this.batchSize = 50;
    this.flushInterval = 5000; // 5 seconds
    
    setInterval(() => this.flush(), this.flushInterval);
  }
  
  track(event) {
    this.queue.push(event);
    
    if (this.queue.length >= this.batchSize) {
      this.flush();
    }
  }
  
  async flush() {
    if (this.queue.length === 0) return;
    
    const events = this.queue.splice(0, this.batchSize);
    await fetch('https://api.norai.com/v1/events/batch', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${API_KEY}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        project_id: 'proj_abc123',
        events
      })
    });
  }
}
```

### 5. Request Only What You Need

Limit the number of results to what you actually need:

```javascript
// Don't request more than you need
const recommendations = await fetchRecommendations({
  user_id: 'user_123',
  limit: 5  // Only request 5 items, not the max
});
```

## Rate Limit Best Practices

1. **Monitor usage**: Track your API usage to stay within limits
2. **Implement caching**: Cache responses when appropriate
3. **Use batch endpoints**: Batch operations reduce API calls
4. **Handle errors gracefully**: Implement retry logic with backoff
5. **Upgrade if needed**: Consider upgrading your tier if you regularly hit limits
6. **Spread load**: Distribute API calls evenly throughout the day
7. **Use webhooks**: Prefer webhooks over polling for async operations

## Monitoring Rate Limits

### Track Usage

```javascript
let apiCallCount = 0;
const startTime = Date.now();

function trackApiCall(response) {
  apiCallCount++;
  const remaining = response.headers.get('X-RateLimit-Remaining');
  const limit = response.headers.get('X-RateLimit-Limit');
  
  console.log(`API Calls: ${apiCallCount}`);
  console.log(`Rate Limit: ${remaining}/${limit}`);
  
  if (remaining < 10) {
    console.warn('Approaching rate limit!');
  }
}
```

### Set Up Alerts

Monitor your usage and set up alerts when approaching limits:

```javascript
async function checkRateLimitStatus() {
  const usage = await fetch('https://api.norai.com/v1/developer/usage', {
    headers: { 'Authorization': `Bearer ${API_KEY}` }
  }).then(r => r.json());
  
  const percentUsed = (usage.api_calls.total / usage.limits.monthly) * 100;
  
  if (percentUsed > 80) {
    sendAlert('Approaching rate limit: ${percentUsed}% used');
  }
}
```

## Increasing Rate Limits

If you need higher rate limits:

1. **Upgrade your tier**: Move to Professional or Enterprise tier
2. **Contact support**: Request custom limits for your use case
3. **Optimize first**: Ensure you're using the API efficiently before requesting increases

## Questions?

If you have questions about rate limits or need assistance optimizing your integration, check the [support page](/docs/support) or contact our team.
